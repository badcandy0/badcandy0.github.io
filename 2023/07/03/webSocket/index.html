<!-- build time:Thu Aug 10 2023 11:12:08 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="lllll" href="http://badcandy0.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="lllll" href="http://badcandy0.github.io/atom.xml"><link rel="alternate" type="application/json" title="lllll" href="http://badcandy0.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="websocket"><link rel="canonical" href="http://badcandy0.github.io/2023/07/03/webSocket/"><title>什么是websocket - web前端 | badcandy = lllll</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">什么是websocket</h1><div class="meta"><span class="item" title="创建时间：2023-07-03 22:26:15"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-07-03T22:26:15+08:00">2023-07-03</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>7.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">badcandy</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://t3.picb.cc/2023/07/11/IPqaOc.png"></li><li class="item" data-background-image="https://t3.picb.cc/2023/07/11/IPqFC6.jpeg"></li><li class="item" data-background-image="https://t3.picb.cc/2023/07/11/IPq3sy.jpeg"></li><li class="item" data-background-image="https://t3.picb.cc/2023/07/11/IPqRsM.png"></li><li class="item" data-background-image="https://t3.picb.cc/2023/07/11/IPqLRr.png"></li><li class="item" data-background-image="https://t3.picb.cc/2023/07/11/IPqbPK.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="item" rel="index" title="分类于 web前端"><span itemprop="name">web前端</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://badcandy0.github.io/2023/07/03/webSocket/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="badcandy"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="lllll"></span><div class="body md" itemprop="articleBody"><h1 id="什么是websocket"><a class="anchor" href="#什么是websocket">#</a> 什么是 websocket</h1><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。<br>在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。（维基百科）<br>WebSocket 本质上一种计算机网络应用层的协议，用来弥补 http 协议在持久通信能力上的不足。<br>WebSocket 协议在 2008 年诞生，2011 年成为国际标准。现在最新版本浏览器都已经支持了。<br>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzJTNBJTJGJTJGZW4ud2lraXBlZGlhLm9yZyUyRndpa2klMkZQdXNoX3RlY2hub2xvZ3k=">服务器推送技术</span>的一种。<br>WebSocket 的其他特点包括：<br>（1）建立在 TCP 协议之上，服务器端的实现比较容易。<br>（2）与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>（3）数据格式比较轻量，性能开销小，通信高效。<br>（4）可以发送文本，也可以发送二进制数据。<br>（5）没有同源限制，客户端可以与任意服务器通信。<br>（6）协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。</p><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token literal-property property">ws</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>example<span class="token punctuation">.</span>com<span class="token operator">:</span><span class="token number">80</span><span class="token operator">/</span>some<span class="token operator">/</span>path</pre></td></tr></table></figure><p><img data-src="https://cdn.nlark.com/yuque/0/2023/png/34100937/1680747726512-3bd64b4b-017e-41a6-a6f1-18c5d0c62161.png#averageHue=%23ead2bc&amp;clientId=u417c516c-6efd-4&amp;from=paste&amp;height=467&amp;id=u1b13a572&amp;originHeight=312&amp;originWidth=418&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=91815&amp;status=done&amp;style=none&amp;taskId=u945ad9cd-9626-4a89-a714-e26fda34b05&amp;title=&amp;width=626" alt="image.png"></p><h2 id="为什么需要-websocket"><a class="anchor" href="#为什么需要-websocket">#</a> 为什么需要 WebSocket？</h2><p>我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？<br>因为 HTTP 协议有一个缺陷：通信只能由客户端发起，不具备服务器推送能力。<br>举例来说，我们想了解查询今天的实时数据，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。<br><img data-src="https://cdn.nlark.com/yuque/0/2023/png/34100937/1680747765516-572cbd3a-965f-4afc-9f42-5c4a531af057.png#averageHue=%23c5b8a4&amp;clientId=u417c516c-6efd-4&amp;from=paste&amp;height=479&amp;id=u5f988d12&amp;originHeight=479&amp;originWidth=638&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=105900&amp;status=done&amp;style=none&amp;taskId=ubb07dbc4-b7e0-4f7c-85a5-e37540b2ed6&amp;title=&amp;width=638" alt="image.png"><br>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cHMlM0ElMkYlMkZ3d3cucHVibnViLmNvbSUyRmJsb2clMkYyMDE0LTEyLTAxLWh0dHAtbG9uZy1wb2xsaW5nJTJG"> &quot;轮询&quot;</span>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。<br>在 WebSocket 协议出现以前，创建一个和服务端进双通道通信的 web 应用，需要依赖 HTTP 协议，进行不停的轮询，这会导致一些问题：</p><ul><li>服务端被迫维持来自每个客户端的大量不同的连接</li><li>大量的轮询请求会造成高开销，比如会带上多余的 header，造成了无用的数据传输。</li></ul><p>http 协议本身是没有持久通信能力的，但是我们在实际的应用中，是很需要这种能力的，所以，为了解决这些问题，WebSocket 协议由此而生，于 2011 年被 IETF 定为标准 RFC6455，并被 RFC7936 所补充规范。<br>并且在 HTML5 标准中增加了有关 WebSocket 协议的相关 api，所以只要实现了 HTML5 标准的客户端，就可以与支持 WebSocket 协议的服务器进行全双工的持久通信了。</p><h2 id="websocket-与-http-的区别"><a class="anchor" href="#websocket-与-http-的区别">#</a> WebSocket 与 HTTP 的区别</h2><p>WebSocket 与 HTTP 的关系图：<br><img data-src="https://cdn.nlark.com/yuque/0/2023/png/34100937/1680748375856-c3ec39b7-4c1f-462b-93ac-3fef37badfd5.png#averageHue=%23fafdfa&amp;clientId=u417c516c-6efd-4&amp;from=paste&amp;height=346&amp;id=ud425a0e9&amp;originHeight=250&amp;originWidth=555&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=56762&amp;status=done&amp;style=none&amp;taskId=ua462056f-7c80-4c13-b0d2-cac8ae70e09&amp;title=&amp;width=767.5" alt="image.png"><br><strong>相同点：</strong> 都是一样基于 TCP 的，都是可靠性传输协议。都是应用层协议。<br><strong>联系：</strong> WebSocket 在建立握手时，数据是通过 HTTP 传输的。但是建立之后，在真正传输时候是不需要 HTTP 协议的。<br>下面一张图说明了 HTTP 与 WebSocket 的主要区别：<br><img data-src="https://cdn.nlark.com/yuque/0/2023/png/34100937/1680748407050-7ed47508-2126-4549-9e8f-03bdbbb7453a.png#averageHue=%2355adc4&amp;clientId=u417c516c-6efd-4&amp;from=paste&amp;height=577&amp;id=u808e404f&amp;originHeight=511&amp;originWidth=628&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=178716&amp;status=done&amp;style=none&amp;taskId=ue56c9d06-6b3b-4b7b-94ea-0d8c2b932f5&amp;title=&amp;width=709" alt="image.png"><br>1、WebSocket 是双向通信协议，模拟 Socket 协议，可以双向发送或接受信息，而 HTTP 是单向的；<br>2、WebSocket 是需要浏览器和服务器握手进行建立连接的，而 http 是浏览器发起向服务器的连接。<br>注意：虽然 HTTP/2 也具备服务器推送功能，但 HTTP/2 只能推送静态资源，无法推送指定的信息。</p><h1 id="websocket协议的原理"><a class="anchor" href="#websocket协议的原理">#</a> WebSocket 协议的原理</h1><p>与 http 协议一样，WebSocket 协议也需要通过已建立的 TCP 连接来传输数据。具体实现上是通过 http 协议建立通道，然后在此基础上用真正的 WebSocket 协议进行通信，所以 WebSocket 协议和 http 协议是有一定的交叉关系的。<br>首先，WebSocket 是一个持久化的协议，相对于 HTTP 这种非持久的协议来说。简单的举个例子吧，用目前应用比较广泛的 PHP 生命周期来解释。<br>HTTP 的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了。<br>在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request = Response， 在 HTTP 中永远是这样，也就是说一个 Request 只能有一个 Response。而且这个 Response 也是被动的，不能主动发起。<br>首先 WebSocket 是基于 HTTP 协议的，或者说借用了 HTTP 协议来完成一部分握手。<br>首先我们来看个典型的 WebSocket 握手</p><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token constant">GET</span> <span class="token operator">/</span>chat <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token literal-property property">Host</span><span class="token operator">:</span> server<span class="token punctuation">.</span>example<span class="token punctuation">.</span>com</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token literal-property property">Upgrade</span><span class="token operator">:</span> websocket</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token literal-property property">Connection</span><span class="token operator">:</span> Upgrade</pre></td></tr><tr><td data-num="5"></td><td><pre>Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Key<span class="token operator">:</span> x3JJHMbDL1EzLkh9GBhXDw<span class="token operator">==</span></pre></td></tr><tr><td data-num="6"></td><td><pre>Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Protocol<span class="token operator">:</span> chat<span class="token punctuation">,</span> superchat</pre></td></tr><tr><td data-num="7"></td><td><pre>Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Version<span class="token operator">:</span> <span class="token number">13</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token literal-property property">Origin</span><span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>example<span class="token punctuation">.</span>com</pre></td></tr></table></figure><p>熟悉 HTTP 的童鞋可能发现了，这段类似 HTTP 协议的握手请求中，多了这么几个东西。</p><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token literal-property property">Upgrade</span><span class="token operator">:</span> websocket</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token literal-property property">Connection</span><span class="token operator">:</span> Upgrade</pre></td></tr></table></figure><p>这个就是 WebSocket 的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的请求要用 WebSocket 协议，快点帮我找到对应的助理处理～而不是那个老土的 HTTP。</p><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre>Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Key<span class="token operator">:</span> x3JJHMbDL1EzLkh9GBhXDw<span class="token operator">==</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Protocol<span class="token operator">:</span> chat<span class="token punctuation">,</span> superchat</pre></td></tr><tr><td data-num="3"></td><td><pre>Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Version<span class="token operator">:</span> <span class="token number">13</span></pre></td></tr></table></figure><p>首先， Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠我，我要验证你是不是真的是 WebSocket 助理。<br>然后， Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同 URL 下，不同的服务所需要的协议。简单理解：今晚我要服务 A，别搞错啦～<br>最后， Sec-WebSocket-Version 是告诉服务器所使用的 WebSocket Draft （协议版本），在最初的时候，WebSocket 协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么 Firefox 和 Chrome 用的不是一个版本之类的，当初 WebSocket 协议太多可是一个大难题。。不过现在还好，已经定下来啦～大家都使用同一个版本： 服务员，我要的是 13 岁的噢→_→<br>然后服务器会返回下列东西，表示已经接受到请求， 成功建立 WebSocket 啦！</p><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">101</span> Switching Protocols</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token literal-property property">Upgrade</span><span class="token operator">:</span> websocket</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token literal-property property">Connection</span><span class="token operator">:</span> Upgrade</pre></td></tr><tr><td data-num="4"></td><td><pre>Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Accept<span class="token operator">:</span> HSmrc0sMlYUkAGmm5OPpG2HaGWk<span class="token operator">=</span></pre></td></tr><tr><td data-num="5"></td><td><pre>Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Protocol<span class="token operator">:</span> chat</pre></td></tr></table></figure><p>这里开始就是 HTTP 最后负责的区域了，告诉客户，我已经成功切换协议啦～</p><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token literal-property property">Upgrade</span><span class="token operator">:</span> websocket</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token literal-property property">Connection</span><span class="token operator">:</span> Upgrade</pre></td></tr></table></figure><p>依然是固定的，告诉客户端即将升级的是 WebSocket 协议，而不是 mozillasocket，lurnarsocket 或者 shitsocket。<br>然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key 。 服务器：好啦好啦，知道啦，给你看我的 ID CARD 来证明行了吧。<br>后面的， Sec-WebSocket-Protocol 则是表示最终使用的协议。<br>至此，HTTP 已经完成它所有工作了，接下来就是完全按照 WebSocket 协议进行了。<br>总结，<strong>WebSocket 连接的过程是：</strong></p><ul><li>首先，客户端发起 http 请求，经过 3 次握手后，建立起 TCP 连接；http 请求里存放 WebSocket 支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version 等；</li><li>然后，服务器收到客户端的握手请求后，同样采用 HTTP 协议回馈数据；</li><li>最后，客户端收到连接成功的消息后，开始借助于 TCP 传输信道进行全双工通信。</li></ul><h1 id="websocket的优缺点"><a class="anchor" href="#websocket的优缺点">#</a> Websocket 的优缺点</h1><p><strong>优点：</strong></p><ul><li>WebSocket 协议一旦建议后，互相沟通所消耗的请求头是很小的</li><li>服务器可以向客户端推送消息了</li></ul><p><strong>缺点：</strong></p><ul><li>少部分浏览器不支持，浏览器支持的程度与方式有区别（IE10）</li></ul><h1 id="websocket应用场景"><a class="anchor" href="#websocket应用场景">#</a> <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzJTNBJTJGJTJGbGluay56aGlodS5jb20lMkYlM0Z0YXJnZXQlM0RodHRwcyUyNTNBJTJGJTJGd3d3LnFjbG91ZC5jb20lMkZjb21tdW5pdHklMkZhcnRpY2xlJTJGMTY0ODE2MDAxNDgxMDExODI2JTI1M0Zmcm9tU291cmNlJTI1M0Rnd3pjdy45MzQwNi45MzQwNi45MzQwNg==">WebSocket 应用场景</span></h1><ul><li>即时聊天通信</li><li>多玩家游戏</li><li>在线协同编辑 / 编辑</li><li>实时数据流的拉取与推送</li><li>体育 / 游戏实况</li><li>实时地图位置</li><li>即时 Web 应用程序：即时 Web 应用程序使用一个 Web 套接字在客户端显示数据，这些数据由后端服务器连续发送。在 WebSocket 中，数据被连续推送 / 传输到已经打开的同一连接中，这就是为什么 WebSocket 更快并提高了应用程序性能的原因。 例如在交易网站或比特币交易中，这是最不稳定的事情，它用于显示价格波动，数据被后端服务器使用 Web 套接字通道连续推送到客户端。</li><li>游戏应用程序：在游戏应用程序中，你可能会注意到，服务器会持续接收数据，而不会刷新用户界面。屏幕上的用户界面会自动刷新，而且不需要建立新的连接，因此在 WebSocket 游戏应用程序中非常有帮助。</li><li>聊天应用程序：聊天应用程序仅使用 WebSocket 建立一次连接，便能在订阅户之间交换，发布和广播消息。它重复使用相同的 WebSocket 连接，用于发送和接收消息以及一对一的消息传输。</li></ul><h2 id="不能使用wbesocket的场景"><a class="anchor" href="#不能使用wbesocket的场景">#</a> 不能使用 wbesocket 的场景</h2><p>如果我们需要通过网络传输的任何实时更新或连续数据流，则可以使用 WebSocket。如果我们要获取旧数据，或者只想获取一次数据供应用程序使用，则应该使用 HTTP 协议，不需要很频繁或仅获取一次的数据可以通过简单的 HTTP 请求查询，因此在这种情况下最好不要使用 WebSocket。<br>注意：如果仅加载一次数据，则 RESTful Web 服务足以从服务器获取数据。</p><h1 id="websocket-断线重连"><a class="anchor" href="#websocket-断线重连">#</a> websocket 断线重连</h1><h2 id="如何判断在线离线"><a class="anchor" href="#如何判断在线离线">#</a> 如何判断在线离线？</h2><p>当客户端第一次发送请求至服务端时会携带唯一标识、以及时间戳，服务端到 db 或者缓存去查询改请求的唯一标识，如果不存在就存入 db 或者缓存中，<br>第二次客户端定时再次发送请求依旧携带唯一标识、以及时间戳，服务端到 db 或者缓存去查询改请求的唯一标识，如果存在就把上次的时间戳拿取出来，使用当前时间戳减去上次的时间，<br>得出的毫秒秒数判断是否大于指定的时间，若小于的话就是在线，否则就是离线；</p><h2 id="如何解决断线问题"><a class="anchor" href="#如何解决断线问题">#</a> 如何解决断线问题</h2><p>通过查阅资料了解到 nginx 代理的 websocket 转发，无消息连接会出现超时断开问题。网上资料提到解决方案两种，一种是修改 nginx 配置信息，第二种是 websocket 发送心跳包。<br>下面就来总结一下本次项目实践中解决的 websocket 的断线 和 重连 这两个问题的解决方案。<br>主动触发包括主动断开连接，客户端主动发送消息给后端</p><ol><li>主动断开连接</li></ol><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre>ws<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>主动断开连接，根据需要使用，基本很少用到。</p><ol start="2"><li>主动发送消息</li></ol><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre>ws<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>针对 websocket 断线我们来分析一下，</p><ul><li>断线的可能原因 1：websocket 超时没有消息自动断开连接，应对措施：这时候我们就需要知道服务端设置的超时时长是多少，在小于超时时间内发送心跳包，有 2 中方案：一种是客户端主动发送上行心跳包，另一种方案是服务端主动发送下行心跳包。下面主要讲一下客户端也就是前端如何实现心跳包：首先了解一下心跳包机制跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。在 TCP 的机制里面，本身是存在有心跳包的机制的，也就是 TCP 的选项：SO_KEEPALIVE。系统默认是设置的 2 小时的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。心跳包一般来说都是在逻辑层发送空的 echo 包来实现的。下一个定时器，在一定时间间隔下发送一个空包给客户端，然后客户端反馈一个同样的空包回来，服务器如果在一定时间内收不到客户端发送过来的反馈包，那就只有认定说掉线了。在长连接下，有可能很长一段时间都没有数据往来。理论上说，这个连接是一直保持连接的，但是实际情况中，如果中间节点出现什么故障是难以知道的。更要命的是，有的节点 (防火墙) 会自动把一定时间之内没有数据交互的连接给断掉。在这个时候，就需要我们的心跳包了，用于维持长连接，保活。</li></ul><p>心跳检测步骤：</p><ol><li>客户端每隔一个时间间隔发生一个探测包给服务器</li><li>客户端发包时启动一个超时定时器</li><li>服务器端接收到检测包，应该回应一个包</li><li>如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器</li><li>如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了</li></ol><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 前端解决方案：心跳检测</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">var</span> heartCheck <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">30000</span><span class="token punctuation">,</span> <span class="token comment">//30 秒发一次心跳</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token literal-property property">timeoutObj</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token literal-property property">serverTimeoutObj</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function-variable function">reset</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">clearTimeout</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timeoutObj<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">clearTimeout</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>serverTimeoutObj<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function-variable function">start</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>timeoutObj <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">// 这里发送一个心跳，后端收到后，返回一个心跳消息，</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token comment">//onmessage 拿到返回的心跳就说明连接正常</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            ws<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"ping"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"ping!"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>            self<span class="token punctuation">.</span>serverTimeoutObj <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 如果超过一定时间还没重置，说明后端主动断开了</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                ws<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果 onclose 会执行 reconnect，我们执行 ws.close () 就行了。如果直接执行 reconnect 会触发 onclose 导致重连两次</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>断线的可能原因 2：websocket 异常包括服务端出现中断，交互切屏等等客户端异常中断等等</li></ul><p>当若服务端宕机了，客户端怎么做、服务端再次上线时怎么做？<br>客户端则需要断开连接，通过 onclose 关闭连接，服务端再次上线时则需要清除之间存的数据，若不清除 则会造成只要请求到服务端的都会被视为离线。<br>针对这种异常的中断解决方案就是处理重连，下面我们给出的重连方案是使用 js 库处理：引入 reconnecting-websocket.min.js，ws 建立链接方法使用 js 库 api 方法：</p><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReconnectingWebSocket</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 断线重连：</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">reconnectSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'ws'</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReconnectingWebSocket</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'MozWebSocket'</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>       ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MozWebSocket</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SockJS</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>断网监测支持使用 js 库：offline.min.js</p><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">onLineCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    Offline<span class="token punctuation">.</span><span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Offline<span class="token punctuation">.</span>state<span class="token punctuation">,</span><span class="token string">'---Offline.state'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>socketStatus<span class="token punctuation">,</span><span class="token string">'---this.socketStatus'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>socketStatus<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'网络连接已断开！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>Offline<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'up'</span> <span class="token operator">&amp;&amp;</span> websocket<span class="token punctuation">.</span>reconnectAttempts <span class="token operator">></span> websocket<span class="token punctuation">.</span>maxReconnectInterval<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            window<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">reconnectSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'网络连接成功！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        websocket<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"heartBeat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// 使用：在 websocket 断开链接时调用网络中断监测</span></pre></td></tr><tr><td data-num="19"></td><td><pre>websocket<span class="token punctuation">.</span><span class="token parameter">onclose</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token function">onLineCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><ul><li>WebSocket 是为了在 web 应用上进行双通道通信而产生的协议，相比于轮询 HTTP 请求的方式，WebSocket 有节省服务器资源，效率高等优点。</li><li>WebSocket 中的掩码是为了防止早期版本中存在中间缓存污染攻击等问题而设置的，客户端向服务端发送数据需要掩码，服务端向客户端发送数据不需要掩码。</li><li>WebSocket 中 Sec-WebSocket-Key 的生成算法是拼接服务端和客户端生成的字符串，进行 SHA1 哈希算法，再用 base64 编码。</li><li>WebSocket 协议握手是依靠 HTTP 协议的，依靠于 HTTP 响应 101 进行协议升级转换。</li></ul><div class="tags"><a href="/tags/websocket/" rel="tag"><i class="ic i-tag"></i> websocket</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-07-04 13:38:37" itemprop="dateModified" datetime="2023-07-04T13:38:37+08:00">2023-07-04</time> </span><span id="2023/07/03/webSocket/" class="item leancloud_visitors" data-flag-title="什么是websocket" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="badcandy 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.jpg" alt="badcandy 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>badcandy <i class="ic i-at"><em>@</em></i>lllll</li><li class="link"><strong>本文链接：</strong> <a href="http://badcandy0.github.io/2023/07/03/webSocket/" title="什么是websocket">http://badcandy0.github.io/2023/07/03/webSocket/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"></div><div class="item right"><a href="/2023/07/04/Promise/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;t3.picb.cc&#x2F;2023&#x2F;07&#x2F;11&#x2F;IPqSps.jpeg" title="什么是Promise"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>什么是Promise</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFwebsocket"><span class="toc-number">1.</span> <span class="toc-text">什么是 websocket</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-websocket"><span class="toc-number">1.1.</span> <span class="toc-text">为什么需要 WebSocket？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket-%E4%B8%8E-http-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">WebSocket 与 HTTP 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#websocket%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">WebSocket 协议的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#websocket%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">Websocket 的优缺点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#websocket%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.</span> <span class="toc-text">WebSocket 应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8wbesocket%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.</span> <span class="toc-text">不能使用 wbesocket 的场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#websocket-%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E"><span class="toc-number">5.</span> <span class="toc-text">websocket 断线重连</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF"><span class="toc-number">5.1.</span> <span class="toc-text">如何判断在线离线？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%96%AD%E7%BA%BF%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">如何解决断线问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2023/07/03/webSocket/" rel="bookmark" title="什么是websocket">什么是websocket</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="badcandy" data-src="/images/avatar.png"><p class="name" itemprop="name">badcandy</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">3</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">4</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JhZGNhbmR5MA==" title="https:&#x2F;&#x2F;github.com&#x2F;badcandy0"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9CYWRDYW5keV9fXw==" title="https:&#x2F;&#x2F;twitter.com&#x2F;BadCandy___"><i class="ic i-twitter"></i></span> <a href="/badcandy.loading@qq.com" title="badcandy.loading@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/web%E5%89%8D%E7%AB%AF/" title="分类于 web前端">web前端</a></div><span><a href="/2023/07/03/webSocket/" title="什么是websocket">什么是websocket</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%8E%E4%B8%BAod/" title="分类于 华为od">华为od</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%8E%E4%B8%BAod/node/" title="分类于 node">node</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%8E%E4%B8%BAod/node/javascript/" title="分类于 javascript">javascript</a></div><span><a href="/2023/08/05/%E5%8D%8E%E4%B8%BAod-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%A4%A7%E5%B0%8F%EF%BC%88JS%EF%BC%89/" title="华为od机试-文件目录大小（js）">华为od机试-文件目录大小（js）</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/04/Promise/" title="什么是Promise">什么是Promise</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">badcandy @ badcandy</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">14k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">12 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/07/03/webSocket/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->